local night = { debug = true, build = 'recode' };
local pow   = math.pow
local sin   = math.sin
local cos   = math.cos
local pi    = math.pi
local sqrt  = math.sqrt
local abs   = math.abs
local asin  = math.asin

local function linear(t, b, c, d)
    return c * t / d + b
end

local function inQuad(t, b, c, d)
    t = t / d
    return c * pow(t, 2) + b
end

local function outQuad(t, b, c, d)
    t = t / d
    return -c * t * (t - 2) + b
end

local function inOutQuad(t, b, c, d)
    t = t / d * 2
    if t < 1 then
        return c / 2 * pow(t, 2) + b
    else
        return -c / 2 * ((t - 1) * (t - 3) - 1) + b
    end
end

local function outInQuad(t, b, c, d)
    if t < d / 2 then
        return outQuad(t * 2, b, c / 2, d)
    else
        return inQuad((t * 2) - d, b + c / 2, c / 2, d)
    end
end

local function inCubic(t, b, c, d)
    t = t / d
    return c * pow(t, 3) + b
end

local function outCubic(t, b, c, d)
    t = t / d - 1
    return c * (pow(t, 3) + 1) + b
end

local function inOutCubic(t, b, c, d)
    t = t / d * 2
    if t < 1 then
        return c / 2 * t * t * t + b
    else
        t = t - 2
        return c / 2 * (t * t * t + 2) + b
    end
end

local function outInCubic(t, b, c, d)
    if t < d / 2 then
        return outCubic(t * 2, b, c / 2, d)
    else
        return inCubic((t * 2) - d, b + c / 2, c / 2, d)
    end
end

local function inQuart(t, b, c, d)
    t = t / d
    return c * pow(t, 4) + b
end

local function outQuart(t, b, c, d)
    t = t / d - 1
    return -c * (pow(t, 4) - 1) + b
end

local function inOutQuart(t, b, c, d)
    t = t / d * 2
    if t < 1 then
        return c / 2 * pow(t, 4) + b
    else
        t = t - 2
        return -c / 2 * (pow(t, 4) - 2) + b
    end
end

local function outInQuart(t, b, c, d)
    if t < d / 2 then
        return outQuart(t * 2, b, c / 2, d)
    else
        return inQuart((t * 2) - d, b + c / 2, c / 2, d)
    end
end

local function inQuint(t, b, c, d)
    t = t / d
    return c * pow(t, 5) + b
end

local function outQuint(t, b, c, d)
    t = t / d - 1
    return c * (pow(t, 5) + 1) + b
end

local function inOutQuint(t, b, c, d)
    t = t / d * 2
    if t < 1 then
        return c / 2 * pow(t, 5) + b
    else
        t = t - 2
        return c / 2 * (pow(t, 5) + 2) + b
    end
end

local function outInQuint(t, b, c, d)
    if t < d / 2 then
        return outQuint(t * 2, b, c / 2, d)
    else
        return inQuint((t * 2) - d, b + c / 2, c / 2, d)
    end
end

local function inSine(t, b, c, d)
    return -c * cos(t / d * (pi / 2)) + c + b
end

local function outSine(t, b, c, d)
    return c * sin(t / d * (pi / 2)) + b
end

local function inOutSine(t, b, c, d)
    return -c / 2 * (cos(pi * t / d) - 1) + b
end

local function outInSine(t, b, c, d)
    if t < d / 2 then
        return outSine(t * 2, b, c / 2, d)
    else
        return inSine((t * 2) - d, b + c / 2, c / 2, d)
    end
end

local function inExpo(t, b, c, d)
    if t == 0 then
        return b
    else
        return c * pow(2, 10 * (t / d - 1)) + b - c * 0.001
    end
end

local function outExpo(t, b, c, d)
    if t == d then
        return b + c
    else
        return c * 1.001 * (-pow(2, -10 * t / d) + 1) + b
    end
end

local function inOutExpo(t, b, c, d)
    if t == 0 then return b end
    if t == d then return b + c end
    t = t / d * 2
    if t < 1 then
        return c / 2 * pow(2, 10 * (t - 1)) + b - c * 0.0005
    else
        t = t - 1
        return c / 2 * 1.0005 * (-pow(2, -10 * t) + 2) + b
    end
end

local function outInExpo(t, b, c, d)
    if t < d / 2 then
        return outExpo(t * 2, b, c / 2, d)
    else
        return inExpo((t * 2) - d, b + c / 2, c / 2, d)
    end
end

local function inCirc(t, b, c, d)
    t = t / d
    return (-c * (sqrt(1 - pow(t, 2)) - 1) + b)
end

local function outCirc(t, b, c, d)
    t = t / d - 1
    return (c * sqrt(1 - pow(t, 2)) + b)
end

local function inOutCirc(t, b, c, d)
    t = t / d * 2
    if t < 1 then
        return -c / 2 * (sqrt(1 - t * t) - 1) + b
    else
        t = t - 2
        return c / 2 * (sqrt(1 - t * t) + 1) + b
    end
end

local function outInCirc(t, b, c, d)
    if t < d / 2 then
        return outCirc(t * 2, b, c / 2, d)
    else
        return inCirc((t * 2) - d, b + c / 2, c / 2, d)
    end
end

local function inElastic(t, b, c, d, a, p)
    if t == 0 then return b end

    t = t / d

    if t == 1 then return b + c end

    if not p then p = d * 0.3 end

    local s

    if not a or a < abs(c) then
        a = c
        s = p / 4
    else
        s = p / (2 * pi) * asin(c / a)
    end

    t = t - 1

    return -(a * pow(2, 10 * t) * sin((t * d - s) * (2 * pi) / p)) + b
end

-- a: amplitud
-- p: period
local function outElastic(t, b, c, d, a, p)
    if t == 0 then return b end

    t = t / d

    if t == 1 then return b + c end

    if not p then p = d * 0.3 end

    local s

    if not a or a < abs(c) then
        a = c
        s = p / 4
    else
        s = p / (2 * pi) * asin(c / a)
    end

    return a * pow(2, -10 * t) * sin((t * d - s) * (2 * pi) / p) + c + b
end

-- p = period
-- a = amplitud
local function inOutElastic(t, b, c, d, a, p)
    if t == 0 then return b end

    t = t / d * 2

    if t == 2 then return b + c end

    if not p then p = d * (0.3 * 1.5) end
    if not a then a = 0 end

    local s

    if not a or a < abs(c) then
        a = c
        s = p / 4
    else
        s = p / (2 * pi) * asin(c / a)
    end

    if t < 1 then
        t = t - 1
        return -0.5 * (a * pow(2, 10 * t) * sin((t * d - s) * (2 * pi) / p)) + b
    else
        t = t - 1
        return a * pow(2, -10 * t) * sin((t * d - s) * (2 * pi) / p) * 0.5 + c + b
    end
end

-- a: amplitud
-- p: period
local function outInElastic(t, b, c, d, a, p)
    if t < d / 2 then
        return outElastic(t * 2, b, c / 2, d, a, p)
    else
        return inElastic((t * 2) - d, b + c / 2, c / 2, d, a, p)
    end
end

local function inBack(t, b, c, d, s)
    if not s then s = 1.70158 end
    t = t / d
    return c * t * t * ((s + 1) * t - s) + b
end

local function outBack(t, b, c, d, s)
    if not s then s = 1.70158 end
    t = t / d - 1
    return c * (t * t * ((s + 1) * t + s) + 1) + b
end

local function inOutBack(t, b, c, d, s)
    if not s then s = 1.70158 end
    s = s * 1.525
    t = t / d * 2
    if t < 1 then
        return c / 2 * (t * t * ((s + 1) * t - s)) + b
    else
        t = t - 2
        return c / 2 * (t * t * ((s + 1) * t + s) + 2) + b
    end
end

local function outInBack(t, b, c, d, s)
    if t < d / 2 then
        return outBack(t * 2, b, c / 2, d, s)
    else
        return inBack((t * 2) - d, b + c / 2, c / 2, d, s)
    end
end

local function outBounce(t, b, c, d)
    t = t / d
    if t < 1 / 2.75 then
        return c * (7.5625 * t * t) + b
    elseif t < 2 / 2.75 then
        t = t - (1.5 / 2.75)
        return c * (7.5625 * t * t + 0.75) + b
    elseif t < 2.5 / 2.75 then
        t = t - (2.25 / 2.75)
        return c * (7.5625 * t * t + 0.9375) + b
    else
        t = t - (2.625 / 2.75)
        return c * (7.5625 * t * t + 0.984375) + b
    end
end

local function inBounce(t, b, c, d)
    return c - outBounce(d - t, 0, c, d) + b
end

local function inOutBounce(t, b, c, d)
    if t < d / 2 then
        return inBounce(t * 2, 0, c, d) * 0.5 + b
    else
        return outBounce(t * 2 - d, 0, c, d) * 0.5 + c * .5 + b
    end
end

local function outInBounce(t, b, c, d)
    if t < d / 2 then
        return outBounce(t * 2, b, c / 2, d)
    else
        return inBounce((t * 2) - d, b + c / 2, c / 2, d)
    end
end

local easing = {
    linear       = linear,
    inQuad       = inQuad,
    outQuad      = outQuad,
    inOutQuad    = inOutQuad,
    outInQuad    = outInQuad,
    inCubic      = inCubic,
    outCubic     = outCubic,
    inOutCubic   = inOutCubic,
    outInCubic   = outInCubic,
    inQuart      = inQuart,
    outQuart     = outQuart,
    inOutQuart   = inOutQuart,
    outInQuart   = outInQuart,
    inQuint      = inQuint,
    outQuint     = outQuint,
    inOutQuint   = inOutQuint,
    outInQuint   = outInQuint,
    inSine       = inSine,
    outSine      = outSine,
    inOutSine    = inOutSine,
    outInSine    = outInSine,
    inExpo       = inExpo,
    outExpo      = outExpo,
    inOutExpo    = inOutExpo,
    outInExpo    = outInExpo,
    inCirc       = inCirc,
    outCirc      = outCirc,
    inOutCirc    = inOutCirc,
    outInCirc    = outInCirc,
    inElastic    = inElastic,
    outElastic   = outElastic,
    inOutElastic = inOutElastic,
    outInElastic = outInElastic,
    inBack       = inBack,
    outBack      = outBack,
    inOutBack    = inOutBack,
    outInBack    = outInBack,
    inBounce     = inBounce,
    outBounce    = outBounce,
    inOutBounce  = inOutBounce,
    outInBounce  = outInBounce,
}
local events = {}; do
    local list = {
        ['render'] = {},
        ['createmove'] = {},
        ['aim_ack'] = {},
        ['render_traverse'] = {},
        ['frame_stage'] = {},
        ['createmove_run'] = {},
        ['setup_move'] = {},
        ['console_input'] = {},
        ['wndproc'] = {},
        ['shutdown'] = {},
        ['game_event'] = {},
        ['pre_render'] = {},
    };
    for name, tbl in pairs(list) do
        if not events[name] then
            events[name] = { set = function(self, func) table.insert(tbl, func) end };
        end;
    end;
    function on_frame_stage_notify(stage, pre_original)
        for i = 1, #list.frame_stage do list.frame_stage[i](stage, pre_original) end;
        if stage == csgo.frame_render_start then
            for i = 1, #list.pre_render do list.pre_render[i]() end;
            return
        end
    end;

    function on_paint_traverse()
        for i = 1, #list.render_traverse do list.render_traverse[i]() end;
    end;

    function on_shot_fired(ctx)
        for i = 1, #list.aim_ack do list.aim_ack[i](ctx) end;
    end;

    function on_paint()
        for i = 1, #list.render do
            -- utils.run_delayed(i * 2, function()
            list.render[i]()
            --end)
        end;
    end;

    function on_create_move(cmd, sendpacket)
        local own_cmd = {
            get_command_number = function(self)
                return cmd:get_command_number();
            end,
            view_angles = function(self, new_vec)
                local cmd_view = vector(cmd:get_view_angles());
                if new_vec then cmd:set_view_angles(new_vec.x or cmd_view.x, new_vec.y or cmd_view.y, new_vec.z or 0) end;

                return vector(cmd_view, new_vec and new_vec.z or 0)
            end,
            movement = function(self, new_vec)
                local move = vector(cmd:get_move());
                if new_vec then cmd:set_move(new_vec.x, new_vec.y) end;
                return move;
            end,
            buttons = function(self, button, value)
                local btn = bit.band(cmd:get_buttons(), button) ~= 0;
                if value then cmd:set_buttons(bit.bset(cmd:get_buttons(), math.log(button, 2), tonumber(value))) end;
                return btn;
            end,
            ___max_tickbase = 0,
            is_defensive = function(self, ticks)
                if not ticks then ticks = false end

                local me = entities.get_entity(engine.get_local_player());
                local tickbase = me:get_prop('m_nTickBase');

                if math.abs(tickbase - self.___max_tickbase) > 64 then
                    self.___max_tickbase = 0
                end;

                local defensive_ticks_left = 0;

                if tickbase > self.___max_tickbase then
                    self.___max_tickbase = tickbase;
                elseif self.___max_tickbase > tickbase then
                    defensive_ticks_left = math.min(14, math.max(0, self.___max_tickbase - tickbase - 1))
                end;

                return ticks and defensive_ticks_left or defensive_ticks_left > 0
            end,
            send_packet = sendpacket,
        };
        for i = 1, #list.createmove do
            utils.run_delayed(i * 3, function()
                list.createmove[i](own_cmd)
            end)
        end;
    end;

    function on_run_command(cmd)
        local own_cmd = {
            get_command_number = function(self)
                return cmd:get_command_number();
            end,
            view_angles = function(self, new_vec)
                local cmd_view = vector(cmd:get_view_angles());
                if new_vec then cmd:set_view_angles(new_vec.x or cmd_view.x, new_vec.y or cmd_view.y, new_vec.z or 0) end;

                return vector(cmd_view, new_vec and new_vec.z or 0)
            end,
            movement = function(self, new_vec)
                local move = vector(cmd:get_move());
                if new_vec then cmd:set_move(new_vec.x, new_vec.y) end;
                return move;
            end,
            buttons = function(self, button, value)
                local btn = bit.band(cmd:get_buttons(), button) ~= 0;
                if value then cmd:set_buttons(bit.bset(cmd:get_buttons(), math.log(button, 2), tonumber(value))) end;
                return btn;
            end,
            ___max_tickbase = 0,
            is_defensive = function(self, ticks)
                if not ticks then ticks = false end

                local me = entities.get_entity(engine.get_local_player());
                local tickbase = me:get_prop('m_nTickBase');

                if math.abs(tickbase - self.___max_tickbase) > 64 then
                    self.___max_tickbase = 0
                end;

                local defensive_ticks_left = 0;

                if tickbase > self.___max_tickbase then
                    self.___max_tickbase = tickbase;
                elseif self.___max_tickbase > tickbase then
                    defensive_ticks_left = math.min(14, math.max(0, self.___max_tickbase - tickbase - 1))
                end;

                return ticks and defensive_ticks_left or defensive_ticks_left > 0
            end,
        };
        for i = 1, #list.createmove_run do
            utils.run_delayed(i * 3, function()
                list.createmove_run[i](own_cmd)
            end)
        end;
    end;

    function on_setup_move(cmd)
        local own_cmd = {
            get_command_number = function(self) return cmd:get_command_number() end,
            view_angles = function(self, new_vec)
                local cmd_view = vector(cmd:get_view_angles());
                if new_vec then cmd:set_view_angles(new_vec.x or cmd_view.x, new_vec.y or cmd_view.y, new_vec.z or 0) end;

                return vector(cmd_view, new_vec and new_vec.z or 0)
            end,
            movement = function(self, new_vec)
                local move = vector(cmd:get_move());
                if new_vec then cmd:set_move(new_vec.x, new_vec.y) end;
                return move;
            end,
            buttons = function(self, button, value)
                local btn = bit.band(cmd:get_buttons(), button) ~= 0;
                if value then cmd:set_buttons(bit.bset(cmd:get_buttons(), math.log(button, 2), tonumber(value))) end;
                return btn;
            end,
            ___max_tickbase = 0,
            is_defensive = function(self, ticks)
                if not ticks then ticks = false end

                local me = entities.get_entity(engine.get_local_player());
                local tickbase = me:get_prop('m_nTickBase');

                if math.abs(tickbase - self.___max_tickbase) > 64 then
                    self.___max_tickbase = 0
                end;

                local defensive_ticks_left = 0;

                if tickbase > self.___max_tickbase then
                    self.___max_tickbase = tickbase;
                elseif self.___max_tickbase > tickbase then
                    defensive_ticks_left = math.min(14, math.max(0, self.___max_tickbase - tickbase - 1))
                end;

                return ticks and defensive_ticks_left or defensive_ticks_left > 0
            end,
        };
        for i = 1, #list.setup_move do
            utils.run_delayed(i * 3, function()
                list.setup_move[i](own_cmd)
            end)
        end;
    end;

    function on_input(msg, wParam, lParam)
        for i = 1, #list.wndproc do list.wndproc[i](msg, wParam, lParam) end;
    end;

    function on_console_input(msg)
        for i = 1, #list.console_input do list.console_input[i](msg) end;
    end;

    function on_shutdown()
        for i = 1, #list.shutdown do list.shutdown[i]() end;
    end;

    function on_shot_registered(ctx)
        for i = 1, #list.aim_ack do list.aim_ack[i](ctx) end;
    end;

    function on_game_event(ctx)
        for i = 1, #list.game_event do list.game_event[i](ctx) end;
    end;
end;
if not info.fatality.allow_insecure then
    error('Script requires \"Allow unsafe scripts\"', 4);
    return
end;
local script = {
    name = "night",
    build = "recode",
    type = "beta",
    version = 0,
};
local function redefine(c)
    if type(c) ~= 'table' then return c end;
    local d = {};
    for e, f in pairs(c) do d[redefine(e)] = redefine(f) end;
    return d;
end;
local vector = math.vec3
local table, math, string, ffi = redefine(table), redefine(math), redefine(string), redefine(ffi)
local gui, _render, db, input, panorama, material, fs, zip, globals, fatality, rule, server = redefine(gui),
    redefine(render), redefine(database), redefine(input), redefine(panorama), redefine(mat), redefine(fs),
    redefine(zip), global_vars, redefine(info.fatality), redefine(game_rules), redefine(info.server);
local function vtable_entry(instance, index, type) return ffi.cast(type, (ffi.cast("void***", instance)[0])[index]) end;
local function vtable_thunk(_type, index)
    local ffitype = ffi.typeof(_type)
    return function(class, ...)
        local this = ffi.cast("void***", class)
        return ffi.cast(ffitype, this[0][index])(this, ...)
    end
end;
local function vtable_bind(module, interface, index, typestring)
    local instance = utils.find_interface(module, interface) or error("invalid interface");
    local fnptr = vtable_entry(instance, index, ffi.typeof(typestring)) or error("invalid vtable");
    return function(...) return fnptr(tonumber(ffi.cast("void***", instance)), ...) end;
end;
string.insert = function(a, b, pos) return string.sub(a, 1, pos) .. b .. string.sub(a, pos + 1) end;
string.limit = function(s, l, c)
    local r, i = {}, 1
    for w in string.gmatch(s, ".[\128-\191]*") do
        i, r[i] = i + 1, w
        if i > l then
            if c then r[i] = c == true and "..." or c end
            break
        end
    end
    return table.concat(r)
end;
math.e = 2.71828;
math.gratio = 1.6180339887;
math.randomseed(utils.get_unix_time() - 143);
math.round             = function(v) return math.floor(v + 0.5) end;
math.roundb            = function(v, d) return math.floor(v + 0.5) / (d or 0) ^ 1 end;
math.clamp             = function(x, a, b) if a > x then return a elseif b < x then return b else return x end end;
math.lerp              = function(a, b, w) return a + (b - a) * w end;
math.normalize_yaw     = function(yaw) return (yaw + 180) % -360 + 180 end;
math.normalize_angle   = function(angle)
    if angle < -180 then angle = angle + 360 end
    if angle > 180 then angle = angle - 360 end
    return angle
end
math.normalize_pitch   = function(pitch) return math.clamp(pitch, -89, 89) end;
math.closest_ray_point = function(p, s, e)
    local t, d = p - s, e - s
    local l = d:length()
    d = d / l
    local r = d:dot(t)
    if r < 0 then return s elseif r > l then return e end
    return s + d * r
end;
math.bool              = function(c, a, b) if c then return a else return b end end;
local entity           = {}
entity.get_origin      = function(ent)
    if not ent then return vector(0, 0, 0) end
    local x, y = ent:get_prop("m_vecOrigin")
    return vector(x, y, ent:get_prop("m_vecOrigin[2]"))
end;
entity.get_threat      = function()
    local me = entities.get_entity(engine.get_local_player());
    if not me or not me:is_alive() then return end
    local my_origin = vector(me:get_prop("m_vecOrigin[0]"), me:get_prop("m_vecOrigin[1]"),
        me:get_prop("m_vecOrigin[2]"))
    if not my_origin then return end
    local threat, distance = nil, math.huge

    entities.for_each_player(function(player)
        if player:is_enemy() then
            local player_origin = vector(player:get_prop("m_vecOrigin[0]"), player:get_prop("m_vecOrigin[1]"),
                player:get_prop("m_vecOrigin[2]"));
            if player_origin ~= math.vec3(0, 0, 0) and player:is_alive() then
                local dist = my_origin:dist(player_origin)
                if dist < distance then
                    distance = dist
                    threat = player
                end
            end
        end
    end)
    return threat
end;
local helpers          = {}; do
    helpers.to_hex = function(r, g, b, a)
        return string.format("%02x%02x%02x%02x", r, g, b, a);
    end;
    helpers.to_rgba = function(hex)
        hex = string.gsub(hex, "^#", "")
        return tonumber(string.sub(hex, 1, 2), 16), tonumber(string.sub(hex, 3, 4), 16),
            tonumber(string.sub(hex, 5, 6), 16), tonumber(string.sub(hex, 7, 8), 16) or 255
    end
end
local color
do
    local create

    --
    local mt = {
        __eq = function(a, b)
            return a.r == b.r and a.g == b.g and a.b == b.b and a.a == b.a
        end,
        lerp = function(f, t, w)
            return create(f.r + (t.r - f.r) * w, f.g + (t.g - f.g) * w, f.b + (t.b - f.b) * w, f.a + (t.a - f.a) * w)
        end,
        to_hex = helpers.to_hex,
        alphen = function(self, a, r)
            return create(self.r, self.g, self.b, r and a * self.a or a)
        end,
    }
    mt.__index = mt

    create = ffi.metatype(ffi.typeof("struct { uint8_t r; uint8_t g; uint8_t b; uint8_t a; }"), mt)

    --
    color = setmetatable({
        rgb = function(r, g, b, a)
            r = math.min(r or 255, 255)
            return create(r, g and math.min(g, 255) or r, b and math.min(b, 255) or r, a and math.min(a, 255) or 255)
        end,
        hex = function(hex)
            local r, g, b, a = helpers.to_rgba(hex)
            return create(r, g, b, a)
        end
    }, {
        __call = function(self, r, g, b, a)
            return type(r) == "string" and self.hex(r) or self.rgb(r, g, b, a)
        end,
    })
end


local anim
do
    local mt, animators = {}, setmetatable({}, { __mode = "kv" })
    local frametime, g_speed = globals.frametime, 1
    anim = {
        pulse = 0,
        easings = {
            pow = {
                function(x, p) return 1 - ((1 - x) ^ (p or 3)) end,
                function(x, p) return x ^ (p or 3) end,
                function(x, p) return x < 0.5 and 4 * math.pow(x, p or 3) or 1 - math.pow(-2 * x + 2, p or 3) * 0.5 end,
            }
        },
        lerp = function(a, b, s, t)
            local c = a + (b - a) * frametime * (s or 8) * g_speed
            return math.abs(b - c) < (t or .005) and b or c
        end,
        condition = function(id, c, s, e)
            local ctx = id[1] and id or animators[id]
            if not ctx then
                animators[id] = { c and 1 or 0, c }; ctx = animators[id]
            end

            s = s or 4
            local cur_s = s
            if type(s) == "table" then cur_s = c and s[1] or s[2] end

            ctx[1] = math.clamp(ctx[1] + (frametime * math.abs(cur_s) * g_speed * (c and 1 or -1)), 0, 1)

            return (ctx[1] % 1 == 0 or cur_s < 0) and ctx[1] or
                anim.easings.pow[e and (c and e[1][1] or e[2][1]) or (c and 1 or 3)](ctx[1],
                    e and (c and e[1][2] or e[2][2]) or 3)
        end
    }
    mt = {
        __call = anim.condition
    }
    events.render:set(function()
        anim.pulse = math.abs(global_vars.realtime * 1 % 2 - 1)
        frametime = global_vars.frametime
    end)
end
local clipboard
do
    local char_array = ffi.typeof "char[?]"

    local native = {
        GetClipboardTextCount = vtable_bind("vgui2.dll", "VGUI_System010", 7, "int(__thiscall*)(void*)"),
        SetClipboardText = vtable_bind("vgui2.dll", "VGUI_System010", 9, "void(__thiscall*)(void*, const char*, int)"),
        GetClipboardText = vtable_bind("vgui2.dll", "VGUI_System010", 11,
            "int(__thiscall*)(void*, int, const char*, int)")
    }

    clipboard = {
        get = function()
            local length = native.GetClipboardTextCount()
            if length == 0 then return end

            local array = char_array(length)

            native.GetClipboardText(0, array, length)
            return ffi.string(array, length - 1)
        end,
        set = function(text)
            text = tostring(text)
            native.SetClipboardText(text, #text)
        end
    }
end

local colors = {
    hex   = "\ad2c0d8FF",
    back  = color.rgb(23, 26, 28),
    dark  = color.rgb(5, 6, 8),
    white = color.rgb(255),
    black = color.rgb(0),
    null  = color.rgb(0, 0, 0, 0),
    text  = color.rgb(230),
}
local printc
do
    printc = function(...)
        for i, v in ipairs { ... } do
            local r = "\aD9D9D9" ..
                string.gsub(tostring(v), "[\r\v]", { ["\r"] = "\aD9D9D9", ["\v"] = "\a" .. (colors.hex:sub(1, 7)) })
            for col, text in r:gmatch("\a(%x%x%x%x%x%x)([^\a]*)") do
                local clr = color.hex(col)
                utils.print_console(text, render.color(clr.r, clr.g, clr.b, clr.a))
            end
        end
        utils.print_console("\n")
    end
end
night.print = function(...)
    printc("  \vnight\r  ", ...)
end
night.dev = true
night.debug = function(...)
    if night.dev then
        printc("  \vDEBUG\r  ", ...)
        --utils.print_dev_console('  DEBUG  ' .. tostring(...) .. '\n')
    end
end

local mouse = { x = 0, y = 0 }
do
    local unlock_cursor = vtable_bind("vguimatsurface.dll", "VGUI_Surface031", 66, "void(__thiscall*)(void*)")
    local lock_cursor = vtable_bind("vguimatsurface.dll", "VGUI_Surface031", 67, "void(__thiscall*)(void*)")

    mouse.lock = function(bool)
        if bool then lock_cursor() else unlock_cursor() end
    end

    mouse.in_bounds = function(x, y, w, h)
        return (mouse.x >= x and mouse.y >= y) and (mouse.x <= (x + w) and mouse.y <= (y + h))
    end

    mouse.pressed = function(key)
        return input.is_key_down(key or 0x01)
    end

    events.render:set(function()
        mouse.x, mouse.y = input.get_cursor_pos()
    end)
end
local me = {}; do
    me.player = entities.get_entity(engine.get_local_player());
    me.origin = vector();
    me.valid = false;
    me.threat = entity.get_threat();
    me.velocity = 0;
    me.side = -1;
    events.createmove_run:set(function()
        me.player = entities.get_entity(engine.get_local_player());
        me.valid = me.player ~= nil;
        me.threat = me.valid and entity.get_threat() or 1;
    end)
end;
local cvars = { cache = 0 }

local c_item = {};
local ui = {}
c_item.__index = c_item;
ui.override = {
    cache = {},
    system = function(self, name, condition, variable_t)
        if self.cache[name] == nil then
            self.cache[name] = {}
            self.cache[name].override = false
            self.cache[name].value = {}
        end;
        if condition then
            if not self.cache[name].override then
                for Path, Value in pairs(variable_t) do
                    if type(Value) == 'number' then
                        self.cache[name].value[Path] = gui.get_config_item(Path):get_int()
                    elseif type(Value) == 'boolean' then
                        self.cache[name].value[Path] = gui.get_config_item(Path):get_bool()
                    end
                end
                self.cache[name].override = true
            end
            for Path, Value in pairs(variable_t) do
                if type(Value) == 'number' then
                    gui.get_config_item(Path):set_int(tonumber(Value))
                elseif type(Value) == 'boolean' then
                    gui.get_config_item(Path):set_bool(string.to_boolean(Value))
                end
            end
        else
            if self.cache[name].override then
                for Path, Value in pairs(variable_t) do
                    if type(Value) == 'number' then
                        gui.get_config_item(Path):set_int(tonumber(self.cache[name].value[Path]))
                    elseif type(Value) == 'boolean' then
                        gui.get_config_item(Path):set_bool(string.to_boolean(self.cache[name].value[Path]))
                    end
                end
                self.cache[name].override = false
            end
        end
    end
};
ui.items = {}; do
    string.to_boolean = function(str)
        if str == "true" or str == "false" then
            return (str == "true")
        else
            return str
        end
    end;
    function ui.slider(name, path, min, max, step)
        return setmetatable({
            item = gui.add_slider(name, path, min, max, step or 1),
            path = path .. ">" .. name,
            name = name,
            own = true,
            save = true,
            item_type = "slider_t"
        }, c_item);
    end;

    function ui.find(path, _type)
        return setmetatable({
            item = gui.get_config_item(path),
            path = path,
            item_type = _type,
            own = false,
        }, c_item);
    end;

    function ui.checkbox(name, path)
        return setmetatable({
            item = gui.add_checkbox(name, path),
            path = path .. ">" .. name,
            name = name,
            own = false,
            item_type = "checkbox_t"
        }, c_item);
    end;

    function ui.keybind(name, path)
        return setmetatable({
            item = gui.add_checkbox(name, path),
            keybind = gui.add_keybind(path .. ">" .. name),
            path = path .. ">" .. name,
            name = name,
            own = true,
            item_type = "keybind_t"
        }, c_item);
    end;

    function ui.listbox(name, path, items)
        return setmetatable({
            item = gui.add_listbox(name, path, -1, false, items),
            path = path .. ">" .. name,
            name = name,
            own = true,
            item_type = "listbox_t"
        }, c_item);
    end;

    function ui.textbox(name, path)
        return setmetatable({
            item = gui.add_textbox(name, path),
            path = path .. ">" .. name,
            name = name,
            own = true,
            item_type = "textbox_t"
        }, c_item);
    end;

    function ui.combo(name, path, items)
        return setmetatable({
            item = gui.add_combo(name, path, items),
            path = path .. ">" .. name,
            name = name,
            own = true,
            items = {},
            item_type = "combo_t"
        }, c_item);
    end

    function ui.multicombo(name, path, _items)
        return setmetatable({
            item = { gui.add_multi_combo(name, path, _items) },
            path = path .. ">" .. name,
            name = name,
            own = true,
            items = items,
            item_type = "multi_combo_t"
        }, c_item);
    end;

    function ui.button(name, path, callback)
        return setmetatable({
            item = { gui.add_button(name, path, callback) },
            path = path .. ">" .. name,
            name = name,
            own = true,
            item_type = "button_t"
        }, c_item);
    end;

    function c_item:get_path()
        if self.path ~= nil then
            return self.path
        else
            return error(
                "Current item`s path == nil")
        end
    end;

    function c_item:get_name()
        if self.name ~= nil then
            return self.name
        else
            return error(
                "Current item`s name == nil")
        end
    end;

    function c_item:type(type) return type and self.item_type == type or self.item_type end;

    function c_item:count_items()
        if self:type("multi_combo_t") or self:type("combo_t") then return #self.items end
        return error("Item ~= multicombo")
    end;

    function c_item:add_colorpicker(alpha, default)
        return setmetatable({
            item = gui.add_colorpicker(self.path, alpha or false, default or render.color(255, 255, 255, 255)),
            own = true,
            item_type = "colorpicker_t"
        }, c_item);
    end;

    function c_item:visible(value)
        if self.path ~= nil then
            return gui.set_visible(self.path, value)
        else
            return
                error("Current item`s path == nil")
        end
    end;

    function c_item:set_items(items)
        if self.item_type == "listbox_t" and self.own then
            return gui.set_listbox_items(self.path, items)
        elseif self.item_type == "combo_t" and self.own then
            return gui.set_combo_items(self.path, items)
        else
            return error("Current item ~= listbox or item isn`t owned")
        end;
    end;

    function c_item:get_keybind()
        if self.item_type == "keybind_t" then
            return gui.get_keybind(self.path)
        else
            return
                error("Current item ~= keybind")
        end
    end;

    function c_item:get_items()
        if self:type() == "listbox_t" then
            return gui.get_listbox_items(self.path)
        elseif self:type() == "combo_t" then
            return gui.get_combo_items(self.path)
        else
            return error("Current item ~= listbox or item isn`t owned")
        end
    end;

    function c_item:set_path(path) self.path = path end;

    function c_item:get(_item)
        if self.item_type == "multi_combo_t" then
            local result = {}
            for _, cfg_item in pairs(self.item) do table.insert(result, cfg_item:get_bool()) end;
            return result[_item];
        elseif self.item_type == "slider_t" then
            return gui.get_config_item(self.path):get_int();
        elseif self.item_type == "combo_t" then
            if _item then
                return gui.get_config_item(self.path):get_int() == _item
            else
                return gui.get_config_item(
                    self.path):get_int()
            end;
        elseif self.item_type == "listbox_t" then
            return gui.get_config_item(self.path):get_int();
        elseif self.item_type == "textbox_t" then
            return gui.get_config_item(self.path):get_string();
        elseif self.item_type == "colorpicker_t" then
            return self.item:get_color();
        elseif self.item_type == "checkbox_t" then
            return gui.get_config_item(self.path):get_bool();
        elseif self.item_type == "keybind_t" then
            return gui.get_config_item(self.path):get_bool();
        elseif self.item_type == "button_t" then
            error("Current item == button")
        end;
    end;

    function c_item:set(value, _item)
        if self.item_type == "slider_t" then
            return gui.get_config_item(self.path):set_int(tonumber(value))
        elseif self.item_type == "combo_t" then
            return gui.get_config_item(self.path):set_int(tonumber(value))
        elseif self.item_type == "button_t" then
            error("Current item == button")
        elseif self.item_type == "multi_combo_t" then
            if type(value) ~= "table" then
                self.item[_item]:set_bool(string.to_boolean(value))
            else
                for i, v in pairs(value) do self.item[i]:set_bool(string.to_boolean(v)) end
            end
        elseif self.item_type == "listbox_t" then
            return gui.get_config_item(self.path):set_int(tonumber(value))
        elseif self.item_type == "textbox_t" then
            return gui.get_config_item(self.path):set_string(value)
        elseif self.item_type == "colorpicker_t" then
            return self.item:set_color(value)
        elseif self.item_type == "checkbox_t" then
            return gui.get_config_item(self.path):set_bool(value ~= nil and string.to_boolean(value) or
                string.to_boolean(value))
        elseif self.item_type == "keybind_t" then
            return gui.get_config_item(self.path):set_bool(value)
        end;
    end;

    function c_item:add_callback(func) return self.item:set_callback(func) end;

    function c_item:override(condition, value) ui.override:system(self.path, condition, { [self.path] = value }) end;
end
local size = vector(_render.get_screen_size())
local x, y = size.x / 2, size.y / 2
local render
do
    render = {};
    render.load_font = function(font, size, flags)
        return _render.create_font(font .. ".ttf", size, flags or 0)
    end
    render.fonts = {
        pixel = _render.font_esp,
        gamesense = render.load_font('calibrib', 24, _render.font_flag_shadow),
        verdana = render.load_font("calibri", 12, _render.font_flag_shadow),
        verdana_bold = render.load_font("calibrib", 12, _render.font_flag_shadow),
    }
    render.get_text_size = function(font, text)
        local font_str = render.fonts.pixel
        if font == "-" then
            font_str = render.fonts.pixel
        end
        if font == "c" then
            font_str = render.fonts.verdana
        end
        if font == "cb" then
            font_str = render.fonts.verdana_bold
        end
        if font == "cb+" then
            font_str = render.fonts.gamesense
        end
        local s = text:gsub("\a(%x%x%x%x%x%x%x%x)", "")
        local w, h = _render.get_text_size(font_str, s)
        if font_str == _render.font_esp then h = h * 0.625 end;
        return vector(w, h)
    end
    render.text = function(font, position, str, clr, center)
        local font_str = render.fonts.pixel
        if font == "-" then
            font_str = render.fonts.pixel
        end
        if font == "c" then
            font_str = render.fonts.verdana
        end
        if font == "cb" then
            font_str = render.fonts.verdana_bold
        end
        if font == "cb+" then
            font_str = render.fonts.gamesense
        end
        local x = position.x;
        local y = position.y;
        if string.len(str) == 0 then return end
        local txt_w = render.get_text_size(font, str)
        if center then
            x = x - txt_w.x / 2
        end
        local start, _end = string.find(str, "\a(%x%x%x%x%x%x%x%x)")
        if start then
            if start ~= 1 then
                local renderString = str:sub(0, start - 1)
                _render.text(font_str, x, y, renderString, _render.color(clr.r, clr.g, clr.b, clr.a or 255))
                local textSizeX, textSizeY = render.get_text_size(font, renderString)
                str = str:sub(start, str:len())
                render.text(font_str, vector(x + textSizeX.x, y), str, _render.color(clr.r, clr.g, clr.b, clr.a or 255))
            else
                local stringEnd = str:len()
                local renderString = str:sub(_end + 1, stringEnd)
                local secondSearch, secondEnd = str.find(renderString, "\a(%x%x%x%x%x%x%x%x)")
                if secondSearch then
                    renderString = str:sub(_end + 1, secondEnd)
                    stringEnd = secondEnd
                end
                local hexCode = str:sub(start + 1, End)
                clr = color(tostring(hexCode))
                local clrr = _render.color(clr.r, clr.g, clr.b, clr.a or 255)
                _render.text(font_str, x, y, renderString, clrr)
                local textSizeX, textSizeY = render.get_text_size(font, renderString)
                str = str:sub(stringEnd + 1, str:len())
                render.text(font, vector(x + textSizeX.x, y), str, clrr)
            end
        else
            _render.text(font_str, x, y, str, _render.color(clr.r, clr.g, clr.b, clr.a or 255))
        end;
    end
    render.load_icon = function(path)
        return _render.create_texture(path)
    end
    render.rect = function(pos, size, color)
        local clr = _render.color(color.r, color.g, color.b, color.a)
        local x, y = pos.x, pos.y
        local w, h = size.x, size.y
        return _render.rect(x, y, x + w, y + w, clr)
    end
    render.rect_multicolor = function(pos, size, top_left, top_right, bottom_right, bottom_left)
        local clr = _render.color(top_left.r, top_left.g, top_left.b, top_left.a)
        local clr1 = _render.color(top_right.r, top_right.g, top_right.b, top_right.a)
        local clr2 = _render.color(bottom_right.r, bottom_right.g, bottom_right.b, bottom_right.a)
        local clr3 = _render.color(bottom_left.r, bottom_left.g, bottom_left.b, bottom_left.a)
        local x, y = pos.x, pos.y
        local w, h = size.x, size.y
        return _render.rect_filled_multicolor(x, y, x + w, y + h, clr, clr1, clr2, clr3)
    end
    render.rect_filled = function(pos, size, color, round, flags)
        local clr = _render.color(color.r, color.g, color.b, color.a)
        local x, y = pos.x, pos.y
        local w, h = size.x, size.y
        if round ~= nil then
            return _render.rect_filled_rounded(x, y, x + w, y + h, clr, round, flags or _render.all)
        else
            return _render.rect_filled(x, y, x + w, y + h, clr)
        end
    end
    render.line = function(pos, size, color)
        local clr = _render.color(color.r, color.g, color.b, color.a)
        return _render.line(pos.x, pos.y, pos.x + size.x, pos.y + size.y, clr)
    end
    render.texture = function(texture, pos, size)
        _render.push_texture(texture)
        _render.push_uv(0, 0, 1, 1)
        render.rect_filled(pos, size, color(255))
        _render.pop_uv()
        _render.pop_texture()
    end
    render.icon = render.load_icon("fatality/night/moon.png")
    render.log = function(pos, text, add)
        local textsize = render.get_text_size('c', text).x
        local x, y = pos.x, pos.y
        render.rect_filled(vector(x - textsize / 2 - 24, y + 80 + add), vector(textsize + 48, 25), color(5, 6, 8, 125), 6,
            _render.all)
        render.rect_filled(vector(x - textsize / 2 + 2, y + 81 + add), vector(2, 23), color(255))
        render.texture(render.icon, vector(x - textsize / 2 - 18, y + 80 + 4 + add), vector(15, 15))
        render.text('c', vector(x + 10, y + 80 + 6 + add), text, color(255, 255, 255, 255), true)
    end
    render.push_indicator = function(text, clr, dist)
        local x, y = 28, size.y - 350
        local ts = render.get_text_size('cb+', text)
        _render.rect_filled_multicolor(5, y + 3 - dist, x + ts.x / 2, y + 37 - dist, _render.color(0, 0, 0, 0),
        _render.color(0, 0, 0, 50),
        _render.color(0, 0, 0, 50), _render.color(0, 0, 0, 0))
        _render.rect_filled_multicolor(x + ts.x / 2, y + 3 - dist, x + ts.x + 28, y + 37 - dist, _render.color(0, 0, 0, 50),
        _render.color(0, 0, 0, 0), _render.color(0, 0, 0, 0), _render.color(0, 0, 0, 50))
        render.text('cb+', vector(x, y + 9 - dist), text, clr)
    end
end
local global = {}; do
    global.states = { 'shared', 'standing', 'moving', 'air', 'air-duck', 'slowwalk', 'duck', 'duck-move', 'on-use',
        'fakelag' };
    global.num = 1.72413793103
end
local config = {}
config.export = function() end
config.import = function(...) end
config.db_name = db.load("names")
config.db_configs = db.load("configs")
config.names = {
    "default",
}
config.configs = {
    "XDD"
}
config.refresh = function()
    return gui.set_listbox_items("lua>tab b>configs", config.db_name)
end
local refs = {
    rage = {
        aimbot = {
            aimbot = {
                target_dormant = ui.find('rage>aimbot>aimbot>target dormant', 'checkbox_t'),
                hide_shot = ui.find('rage>aimbot>aimbot>hide shot', 'checkbox_t'),
                double_tap = ui.find('rage>aimbot>aimbot>double tap', 'checkbox_t'),
                force_extra_safety = ui.find('rage>aimbot>aimbot>force extra safety', 'checkbox_t'),
                headshot_only = ui.find('rage>aimbot>aimbot>headshot only', 'checkbox_t'),
                resolver_mode = ui.find('rage>aimbot>aimbot>resolver mode', 'combo_t'),
            },
            weapon = {
                hitchance = ui.find('rage>aimbot>autosniper>auto>hitchance', 'slider_t'),
                min_damage = ui.find('rage>aimbot>autosniper>auto>min-damage', 'slider_t'),
                override = ui.find('rage>aimbot>autosniper>auto>override', 'checkbox_t'),
                min_damage_override = ui.find('rage>aimbot>autosniper>auto>min-damage override', 'slider_t'),
            },
        },
        anti_aim = {
            fakelag = {
                mode = ui.find("rage>anti-aim>fakelag>mode", "combo_t"),
                limit = ui.find("rage>anti-aim>fakelag>limit", "slider_t"),
            },
            angles = {
                anti_aim = ui.find('rage>anti-aim>angles>anti-aim', 'checkbox_t'),
                pitch = ui.find('rage>anti-aim>angles>pitch', 'combo_t'),
                yaw = ui.find('rage>anti-aim>angles>yaw', 'combo_t'),
                yaw_add = ui.find('rage>anti-aim>angles>yaw add', 'checkbox_t'),
                add = ui.find('rage>anti-aim>angles>add', 'slider_t'),
                freestand = ui.find('rage>anti-aim>angles>freestand', 'checkbox_t'),
                at_fov_target = ui.find('rage>anti-aim>angles>at fov target', 'checkbox_t'),
                spin = ui.find('rage>anti-aim>angles>spin', 'checkbox_t'),
                spin_range = ui.find('rage>anti-aim>angles>spin range', 'slider_t'),
                spin_speed = ui.find('rage>anti-aim>angles>spin speed', 'slider_t'),
                jitter = ui.find('rage>anti-aim>angles>jitter', 'checkbox_t'),
                random = ui.find('rage>anti-aim>angles>random', 'checkbox_t'),
                jitter_range = ui.find('rage>anti-aim>angles>jitter range', 'slider_t'),
                antiaim_override = ui.find('rage>anti-aim>angles>antiaim override', 'checkbox_t'),
                back = ui.find('rage>anti-aim>angles>back', 'checkbox_t'),
                left = ui.find('rage>anti-aim>angles>left', 'checkbox_t'),
                right = ui.find('rage>anti-aim>angles>right', 'checkbox_t'),
            },
            desync = {
                fake = ui.find('rage>anti-aim>desync>fake', 'checkbox_t'),
                fake_amount = ui.find('rage>anti-aim>desync>fake amount', 'slider_t'),
                compensate_angle = ui.find('rage>anti-aim>desync>compensate angle', 'slider_t'),
                freestand_fake = ui.find('rage>anti-aim>desync>freestand fake', 'combo_t'),
                leg_slide = ui.find('rage>anti-aim>desync>leg slide', 'combo_t')
            },
        },
    },
    misc = {
        movement = {
            fake_duck = ui.find('misc>movement>fake duck', 'checkbox_t'),
            peek = ui.find('misc>movement>peek assist', 'checkbox_t'),
            slide = ui.find('misc>movement>slide', 'checkbox_t'),
        }
    },
};
local menu = {}; do
    menu.init = function()
        menu.navigation = ui.listbox("navigation", "lua>tab a", { "global", "antiaim" });
        menu.info = ui.listbox("info", "lua>tab a",
            { "welcome back, " .. cvar.name:get_string(), "made by l3v1y with love//" });
        menu.global_navigation = ui.listbox("global navigation", "lua>tab a", { "visual", "misc" });
        menu.config = {};
        menu.config.list = ui.listbox("configs", "lua>tab b", config.db_name)
        config.refresh()
        menu.config.name = ui.textbox("new config name", "lua>tab b");
        menu.config.add = ui.button("add current config", "lua>tab b", function()
            table.insert(config.names, menu.config.name:get());
            table.insert(config.configs, config.export())
            db.save("names", config.names)
            db.save("configs", config.configs)
            config.db_name = db.load("names")
            config.db_configs = db.load("configs")
            config.refresh()
        end)
        menu.config.load = ui.button("load config", "lua>tab b", function()
            config.import(config.configs[menu.config.list:get() + 1])
            night.print("Config loaded!")
        end)
        menu.config.export = ui.button("export Config", "lua>tab b", function()
            clipboard.set(config.export())
            night.print("Config Exported!")
        end)

        menu.global = {};
        menu.antiaim = {};
        menu.antiaim.buider = {}
        menu.antiaim.states = { '', ' ', '  ', '   ', '    ', '     ', '      ', '       ', '        ', '         ' }
        menu.antiaim.selection = ui.listbox('state', 'lua>tab a', global.states)
        menu.antiaim.additions = ui.multicombo('antiaim additions', 'lua>tab a',
            { 'safe head', 'static manuals', 'disable on warmup', 'disable no enemies alive' })
        for i, name in ipairs(global.states) do
            local inf = menu.antiaim.states[i]
            menu.antiaim.buider[name] = {}
            local ctx = menu.antiaim.buider[name]
            if i > 1 then
                ctx.enable = ui.checkbox(string.format('enable%s', inf), "lua>tab b");
            end
            ctx.base = ui.combo(string.format('base%s', inf), "lua>tab b", { 'local view', 'at target' });
            ctx.type = ui.combo(string.format('yaw modifier%s', inf), 'lua>tab b', { 'static', 'sided', 'x-way' });
            ctx.static = ui.slider(string.format('static%s', inf), 'lua>tab b', -180, 180, 1);

            ctx.left = ui.slider(string.format('left%s', inf), 'lua>tab b', -180, 180, 1);
            ctx.right = ui.slider(string.format('right%s', inf), 'lua>tab b', -180, 180, 1);
            ctx.ways = {};
            ctx.ways_limit = ui.slider(string.format('ways%s', inf), 'lua>tab b', 3, 7, 1);
            ctx.way_show = ui.checkbox(string.format('show ways%s', inf), 'lua>tab b');
            for w = 1, 7 do
                ctx.ways[w] = ui.slider(string.format('way %s%s', w, inf), 'lua>tab b', -180, 180);
            end

            ctx.jitter = ui.combo(string.format('jitter%s', inf), 'lua>tab b', { 'off', 'offset', 'center' });
            ctx.range = ui.slider(string.format('range%s', inf), 'lua>tab b', -180, 180, 1)
            ctx.randomize = ui.slider(string.format('randomize%s', inf), 'lua>tab b', -180, 180, 1)

            ctx.desync = ui.combo(string.format('desync%s', inf), 'lua>tab b',
                { 'off', 'static', 'opposite', 'auto', 'jitter' });
            ctx.amount = ui.slider(string.format('amount%s', inf), 'lua>tab b', -58, 58, 1);
            ctx.compensate = ui.slider(string.format('compensate%s', inf), "lua>tab b", 0, 100, 10);
            ctx.delay = ui.slider(string.format('delay%s', inf), 'lua>tab b', 2, 12, 1)
        end

        menu.visual = {};
        menu.visual.accent = ui.checkbox('acccent color', 'lua>tab a');
        menu.visual.color = menu.visual.accent:add_colorpicker(false);
        menu.visual.watermark = ui.combo('watermark', 'lua>tab a', { 'old', 'wraith', 'luasense', 'modern' });

        menu.visual.indicator = ui.checkbox('under crosshair indicators', 'lua>tab b')
        menu.visual.font_indicator = ui.combo('font', 'lua>tab b', { 'default', 'pixel' })
        menu.visual.animated = ui.checkbox('animated binds', 'lua>tab b')
        menu.visual.gamesense = ui.checkbox('gamesense indicators', 'lua>tab b')
        menu.visual.gamesense_list = ui.multicombo('to show', 'lua>tab b',
            { 'double tap', 'on shot anti-aim', 'dormant aimbot', 'lag compensation', 'fake duck', 'force safepoint',
                'damage override', 'peek assist', 'hitchance override', 'hit rate' })
        menu.visual.spark = ui.checkbox('electric spark', 'lua>tab b')
        menu.visual.scope = {}
        menu.visual.scope_enable = ui.checkbox('custom scope', 'lua>tab a');
        menu.visual.scope_color = menu.visual.scope_enable:add_colorpicker(true)
        menu.visual.scope.removals = ui.multicombo('removals', 'lua>tab a', { 'top', 'right', 'bottom', 'left' });
        menu.visual.scope.length = ui.slider('length', 'lua>tab a', 0, 500, 1);
        menu.visual.scope.offset = ui.slider('offset', 'lua>tab a', 0, 500, 1);
        menu.visual.scope.speed = ui.slider('speed', 'lua>tab a', 0, 20, 1)


        menu.misc = {};
        menu.misc.hitchance = ui.keybind('hitchance override', 'lua>tab b');
        menu.misc.hitchance_int = ui.slider('hitchance', 'lua>tab b', 0, 100, 1);
        menu.misc.fakelag = ui.checkbox('fakelag improver', 'lua>tab b');
        menu.misc.breakers = ui.combo('animation breakers', 'lua>tab a', { 'ground', 'air', 'other' });
        menu.misc.ground = ui.combo("ground breaker", 'lua>tab a', { "off", "static", "jitter", "moonwalk", "kangaroo" });
        menu.misc.air = ui.combo("air breaker", 'lua>tab a', { "off", "static", "jitter", "kangaroo" });
        menu.misc.pitch = ui.checkbox('pitch 0 on land', 'lua>tab a');

        events.render:set(function()
            if not gui.is_menu_open() then return end
            menu.info:visible(menu.navigation:get() == 0);
            menu.global_navigation:visible(menu.navigation:get() == 0)
            menu.antiaim.selection:visible(menu.navigation:get() == 1)
            menu.antiaim.additions:visible(menu.navigation:get() == 1)
            for i, name in ipairs(global.states) do
                local ctx = menu.antiaim.buider[name]
                local check = (i > 1 and ctx.enable:get() or i == 1 and true) and
                    menu.antiaim.selection:get() + 1 == i
                local state = menu.antiaim.selection:get() + 1 == i and menu.navigation:get() == 1
                if i > 1 then
                    ctx.enable:visible(state)
                end
                ctx.base:visible(check and menu.navigation:get() == 1)
                ctx.type:visible(check and menu.navigation:get() == 1)
                ctx.static:visible(check and menu.navigation:get() == 1 and ctx.type:get() == 0)
                ctx.left:visible(check and menu.navigation:get() == 1 and ctx.type:get() == 1)
                ctx.right:visible(check and menu.navigation:get() == 1 and ctx.type:get() == 1)
                ctx.ways_limit:visible(check and menu.navigation:get() == 1 and ctx.type:get() == 2)
                ctx.way_show:visible(check and menu.navigation:get() == 1 and ctx.type:get() == 2)
                for w = 1, 7 do
                    ctx.ways[w]:visible(check and menu.navigation:get() == 1 and ctx.ways_limit:get() >= w and
                        ctx.way_show:get() and ctx.type:get() == 2)
                end
                ctx.jitter:visible(check and menu.navigation:get() == 1)
                ctx.range:visible(check and menu.navigation:get() == 1 and ctx.jitter:get() > 0)
                ctx.randomize:visible(check and menu.navigation:get() == 1 and ctx.jitter:get() > 0)
                ctx.desync:visible(check and menu.navigation:get() == 1)
                ctx.amount:visible(check and menu.navigation:get() == 1 and ctx.desync:get() ~= 0 and
                    ctx.desync:get() ~= 2)
                ctx.compensate:visible(check and menu.navigation:get() == 1 and ctx.desync:get() ~= 0 and
                    ctx.desync:get() ~= 2)
                ctx.delay:visible(check and menu.navigation:get() == 1)
            end

            menu.visual.accent:visible(menu.navigation:get() == 0 and menu.global_navigation:get() == 0)
            menu.visual.watermark:visible(menu.navigation:get() == 0 and menu.global_navigation:get() == 0)

            menu.visual.indicator:visible(menu.navigation:get() == 0 and menu.global_navigation:get() == 0)
            menu.visual.font_indicator:visible(menu.navigation:get() == 0 and menu.global_navigation:get() == 0 and
                menu.visual.indicator:get())
            menu.visual.animated:visible(menu.navigation:get() == 0 and menu.global_navigation:get() == 0 and
                menu.visual.indicator:get())
            menu.visual.gamesense:visible(menu.navigation:get() == 0 and menu.global_navigation:get() == 0)
            menu.visual.gamesense_list:visible(menu.navigation:get() == 0 and menu.global_navigation:get() == 0 and
                menu.visual.gamesense:get())
            menu.visual.scope_enable:visible(menu.navigation:get() == 0 and menu.global_navigation:get() == 0)
            for k, v in pairs(menu.visual.scope) do
                v:visible(menu.navigation:get() == 0 and menu.global_navigation:get() == 0 and
                    menu.visual.scope_enable:get())
            end
            menu.misc.fakelag:visible(menu.navigation:get() == 0 and menu.global_navigation:get() == 1)
            menu.misc.hitchance:visible(menu.navigation:get() == 0 and menu.global_navigation:get() == 1)
            menu.misc.hitchance_int:visible(menu.navigation:get() == 0 and menu.global_navigation:get() == 1)
            menu.misc.breakers:visible(menu.navigation:get() == 0 and menu.global_navigation:get() == 1)
            menu.misc.ground:visible(menu.navigation:get() == 0 and menu.global_navigation:get() == 1 and
                menu.misc.breakers:get() == 0)
            menu.misc.air:visible(menu.navigation:get() == 0 and menu.global_navigation:get() == 1 and
                menu.misc.breakers:get() == 1)
            menu.misc.pitch:visible(menu.navigation:get() == 0 and menu.global_navigation:get() == 1 and
                menu.misc.breakers:get() == 2)
            for k, v in pairs(menu.config) do
                v:visible(menu.navigation:get() == 0 and menu.global_navigation:get() == 2)
            end
        end)
    end
    menu.init()
end

local funcs = {};
funcs.init = function()
    --#region ffi
    local VClientEntityList = utils.find_interface("client.dll", "VClientEntityList003")
    local GetClientEntityFN = vtable_thunk("void*(__thiscall*)(void*, int)", 3)
    local animation_breakers = {}
    animation_breakers.collected_cache = {}
    local breakers = {}; do
        ffi.cdef [[
            struct pose_parameters_t
            {
                char pad[8];
                float m_flStart;
                float m_flEnd;
                float m_flState;
            };
        ]]
        local studio_hdr_offset = 0x2950
        local allanimstate_offset = 0x9960
        local landing_offset = 0x109


        breakers.pose_parameter_pattern = "55 8B EC 8B 45 08 57 8B F9 8B 4F 04 85 C9 75 15"
        breakers.get_pose_parameters = ffi.cast("struct pose_parameters_t*(__thiscall* )(void*, int)",
            utils.find_pattern("client.dll", breakers.pose_parameter_pattern))


        breakers.set_pose = function(self_pointer, layer, start_value, end_value)
            local new_player_pointer = ffi.cast("unsigned int", self_pointer)
            local NULL = 0x0
            if new_player_pointer == NULL then
                return false
            end
            local studio_hdr = ffi.cast("void**", new_player_pointer + studio_hdr_offset)[0]

            if not studio_hdr or studio_hdr == NULL then
                return false
            end

            local pose_parameters = breakers.get_pose_parameters(studio_hdr, layer)
            if not pose_parameters or pose_parameters == NULL then
                return false
            end

            if animation_breakers.collected_cache[layer] == nil then
                animation_breakers.collected_cache[layer] = {}

                animation_breakers.collected_cache[layer].m_flStart = pose_parameters.m_flStart
                animation_breakers.collected_cache[layer].m_flEnd = pose_parameters.m_flEnd
                animation_breakers.collected_cache[layer].m_flState = pose_parameters.m_flState

                animation_breakers.collected_cache[layer].is_applied = false
                return true
            end

            if start_value ~= nil and not animation_breakers.collected_cache[layer].is_applied then
                pose_parameters.m_flStart = start_value
                pose_parameters.m_flEnd = end_value

                pose_parameters.m_flState = (pose_parameters.m_flStart + pose_parameters.m_flEnd) / 2
                animation_breakers.collected_cache[layer].is_applied = true

                return true
            end
            if animation_breakers.collected_cache[layer].is_applied then
                pose_parameters.m_flStart = animation_breakers.collected_cache[layer].m_flStart
                pose_parameters.m_flEnd = animation_breakers.collected_cache[layer].m_flEnd
                pose_parameters.m_flState = animation_breakers.collected_cache[layer].m_flState

                animation_breakers.collected_cache[layer].is_applied = false
                return true
            end
            return false
        end
    end;

    local FFI = {
        ffi.cdef [[
            typedef struct{
                float x;
                float y;
                float z;
            }Vector;

            typedef void(__fastcall*FX_ElectricSparkFn)(const Vector*,int,int,const Vector*);
        ]],
        ffi.cdef [[
            typedef uintptr_t (__thiscall* GetClientEntity_4242425_t)(void*, int);

            typedef struct c_animstate
            {
              char         pad0[0x60];
              void*        pEntity;
              void*        pActiveWeapon;
              void*        pLastActiveWeapon;
              float        flLastUpdateTime;
              int          iLastUpdateFrame;
              float        flLastUpdateIncrement;
              float        flEyeYaw;
              float        flEyePitch;
              float        flGoalFeetYaw;
              float        flLastFeetYaw;
              float        flMoveYaw;
              float        flLastMoveYaw;
              float        flLeanAmount;
            } CCSGOPlayerAnimationState_534535_t;
        ]],
        Update = {
            AnimStateOffset = 0x9960,
        },
        setup = function(self)
            -- Get Entity
            self.ClientEntityList = ffi.cast("void***", utils.find_interface("client.dll", "VClientEntityList003"))
            self.GetClientEntity = ffi.cast("GetClientEntity_4242425_t", self.ClientEntityList[0][3])

            self.GetEntityAddress = function(ent_index)
                return ffi.cast('GetClientEntity_4242425_t', self.ClientEntityList[0][3])(self.ClientEntityList,
                    ent_index)
            end

            self.GetAnimationState = function(entity)
                return ffi.cast('struct c_animstate**',
                    self.GetEntityAddress(entity:get_index()) + self.Update.AnimStateOffset)[0]
            end
        end,
        lFootYaw = 0
    }
    local FX_ElectricSpark = ffi.cast("FX_ElectricSparkFn",
        utils.find_pattern("client.dll", "55 8B EC 83 EC 3C 53 8B D9 89 55 FC 8B 0D ?? ?? ?? ?? 56 57"))

    local vec3 = ffi.new("Vector")
    local QAngle = ffi.new("Vector")

    FFI:setup()
    local rage = {}; do
        rage.get_weapon = function(weapon2)
            if not me.valid then return "ssg08>scout" end
            local weapon = me.player:get_prop("m_hActiveWeapon")
            if not weapon then return "ssg08>scout" end

            local weapon = entities.get_entity_from_handle(weapon)
            if not weapon then return "ssg08>scout" end

            local weapon_t = utils.get_weapon_info(weapon:get_prop("m_iItemDefinitionIndex")).console_name
            if weapon2 then
                return weapon_t
            end
            if weapon_t == "weapon_g3sg1" or weapon_t == "weapon_scar20" then
                return "autosniper>auto"
            elseif weapon_t == "weapon_ssg08" then
                return "ssg08>scout"
            elseif weapon_t == "weapon_awp" then
                return "awp>awp"
            elseif weapon_t == "weapon_revolver" or weapon_t == "weapon_deagle" then
                return "heavy_pistol>heavy pistols"
            elseif weapon_t == "weapon_glock" or weapon_t == "weapon_usp_silencer" or weapon_t == "weapon_hkp2000" or weapon_t == "weapon_elite" or weapon_t == "weapon_p250" or weapon_t == "weapon_fiveseven" or weapon_t == "weapon_tec9" or weapon_t == "weapon_cz75a" then
                return "pistol>pistols"
            else
                return "other>other"
            end
        end;
        rage.get_targets = function()
            rage.target = {}
            entities.for_each_player(function(player)
                if player:is_enemy() then
                    if player:is_alive() or player:is_dormant() then
                        table.insert(rage.target, #rage.target + 1)
                    else
                        table.remove(rage.target, #rage.target + 1)
                    end
                end
            end)
            if not me.player or not me.valid or not me.player:is_alive() then
                rage.target = {}
                return
            end
            return #rage.target
        end
    end

    local visual = {}; do
        visual.anims = { indicator = 0, logs = 0, scope = 0, custom_scope = 0 }
        visual.breath = function(x)
            x = x % 2.0

            if x > 1.0 then
                x = 2.0 - x
            end

            return x
        end
        visual.u8 = function(s)
            return string.gsub(s, "[\128-\191]", "")
        end
        visual.gradient = function(s, clock, clr1, clr2)
            local buffer = {}

            local len = #visual.u8(s)
            local div = 1 / (len - 1)

            local add_r = clr2.r - clr1.r
            local add_g = clr2.g - clr1.g
            local add_b = clr2.b - clr1.b
            local add_a = clr2.a - clr1.a

            for char in string.gmatch(s, ".[\128-\191]*") do
                local t = visual.breath(clock)

                local r = clr1.r + add_r * t
                local g = clr1.g + add_g * t
                local b = clr1.b + add_b * t
                local a = clr1.a + add_a * t
                buffer[#buffer + 1] = "\a"
                buffer[#buffer + 1] = helpers.to_hex(math.round(r), math.round(g), math.round(b), math.round(a))
                buffer[#buffer + 1] = char

                clock = clock - div
            end

            return table.concat(buffer)
        end
    end
    local antiaim = {};
    antiaim.get_side = function(bool)
        local my = me.player
        if not my or not me.valid then return -1 end
        local Info = {
            EyeYaw = FFI.GetAnimationState(my).flEyeYaw,
            FeetYaw = math.normalize_angle(FFI.GetAnimationState(my).flGoalFeetYaw),
        }

        if info.fatality.lag_ticks == 0 then
            FFI.lFootYaw = Info.FeetYaw
        end

        local Angle = Info.EyeYaw - FFI.lFootYaw

        if Info.EyeYaw <= -122 and FFI.lFootYaw >= 0 then
            Angle = 360 + Angle
        end
        if Info.EyeYaw >= 122 and FFI.lFootYaw <= 0 then
            Angle = 360 - Angle
            Angle = -Angle
        end
        return bool and Angle or Angle < 0 and -1 or 1
    end
    antiaim.air_tick = 0;
    antiaim.in_air = false;
    antiaim.get_velocity = function()
        if not me.valid or not me.player:is_alive() then return vector(0, 0, 0) end
        return vector(me.player:get_prop('m_vecVelocity[0]'), me.player:get_prop('m_vecVelocity[1]'),
            me.player:get_prop('m_vecVelocity[2]'))
    end
    antiaim.get_state = function()
        if not me.valid then return 'shared' end
        local ctx = menu.antiaim.buider
        local velocity = antiaim.get_velocity():length()
        local flag = me.player:get_prop('m_fFlags')
        local duck = me.player:get_prop('m_bDucked')
        if ctx['fakelag'].enable:get() then
            if (not refs.rage.aimbot.aimbot.double_tap:get()) and (not refs.rage.aimbot.aimbot.hide_shot:get()) then
                return 'fakelag'
            end
        end
        if flag == 256 or flag == 262 then
            antiaim.in_air = true
            antiaim.air_tick = global_vars.tickcount + 3
        else
            antiaim.in_air = (antiaim.air_tick > global_vars.tickcount) and true or false
        end
        if antiaim.in_air then
            if duck then
                return 'air-duck'
            end
            return 'air'
        end
        if duck then
            if velocity > 5 then
                return 'duck-move'
            end
            return 'duck'
        end
        if velocity > 5 then
            if refs.misc.movement.slide:get() then
                return 'slowwalk'
            end
            return 'moving'
        else
            return 'standing'
        end
        return 'shared'
    end
    antiaim.side = -1
    antiaim.values = {
        packets = 0,
    }
    events.createmove:set(function()
        if info.fatality.lag_ticks == 0 then
            antiaim.side = antiaim.side * -1
        end
    end)
    antiaim.jitter = function(cmd, delay)
        if delay <= 2 then
            return antiaim.side == -1 and 1 or -1
        else
            return (cmd:get_command_number() % (delay * 2)) >= delay and -1 or 1
        end
    end
    antiaim.get = function(cmd, stage, desync, delay, yaw)
        if stage == 0 then
            return false, 0, 0
        end
        if stage == 1 then
            return true, desync * global.num, 1
        end
        if stage == 2 then
            return true,
                100 * ((cmd:buttons(csgo.in_move_right) and -1) or (cmd:buttons(csgo.in_move_left) and 1) or
                    antiaim.get_side()),
                ((cmd:buttons(csgo.in_move_right) and -1) or (cmd:buttons(csgo.in_move_left) and 1) or
                    antiaim.get_side())
        end
        if stage == 3 then
            if yaw < 0 then
                return true, desync * global.num * -1, -1
            end
            if yaw > 0 then
                return true, desync * global.num, 1
            end
            if yaw == 0 then
                return true, 0, 0
            end
        end
        if stage == 4 then
            return true, desync * global.num * antiaim.jitter(cmd, delay),
                antiaim.jitter(cmd, delay)
        end
    end
    antiaim.way = 1
    events.createmove:set(function(cmd)
        local state = 'shared'
        if antiaim.get_state() ~= 'shared' then
            if menu.antiaim.buider[antiaim.get_state()].enable:get() then
                state = antiaim.get_state()
            else
                state = 'shared'
            end
        end
        local ctx = menu.antiaim.buider[state]
        if info.fatality.lag_ticks == 0 then
            antiaim.way = antiaim.way + 1
        end
        if antiaim.way > ctx.ways_limit:get() then antiaim.way = 1 end
        local jitter = antiaim.jitter(cmd, ctx.delay:get())
        antiaim.yaw, antiaim.jitteryaw, antiaim.add = 0, 0, 0
        if ctx.type:get() == 0 then
            antiaim.yaw = ctx.static:get()
        end
        if ctx.type:get() == 1 then
            antiaim.yaw = jitter == -1 and ctx.left:get() or ctx.right:get()
        end
        if ctx.type:get() == 2 then
            antiaim.yaw = ctx.ways[antiaim.way]:get()
        end
        if ctx.jitter:get() == 0 then
            antiaim.jitteryaw = 0
        end
        if ctx.jitter:get() == 1 then
            antiaim.jitteryaw = jitter == -1 and 0 + utils.random_int(-ctx.randomize:get() / 2, ctx.randomize:get() / 2) or
                ctx.range:get() + utils.random_int(-ctx.randomize:get() / 2, ctx.randomize:get() / 2)
        end
        if ctx.jitter:get() == 2 then
            antiaim.jitteryaw = jitter == -1 and
                -ctx.range:get() / 2 + utils.random_int(-ctx.randomize:get() / 2, ctx.randomize:get() / 2) or
                ctx.range:get() / 2 + utils.random_int(-ctx.randomize:get() / 2, ctx.randomize:get() / 2)
        end
        antiaim.add = antiaim.yaw + antiaim.jitteryaw
        local fake, desync, side = antiaim.get(cmd, ctx.desync:get(), ctx.amount:get(), ctx.delay:get(), antiaim.add)
        refs.rage.anti_aim.angles.pitch:set(1)
        refs.rage.anti_aim.angles.at_fov_target:set(ctx.base:get() == 1)
        refs.rage.anti_aim.desync.fake:set(fake)
        refs.rage.anti_aim.desync.fake_amount:set(desync)
        refs.rage.anti_aim.desync.compensate_angle:set(ctx.compensate:get())
        refs.rage.anti_aim.angles.yaw_add:set(true)
        refs.rage.anti_aim.angles.add:set(antiaim.add)
        refs.rage.anti_aim.angles.spin:set(false)
        if menu.antiaim.additions:get(1) then
            local weapon = rage.get_weapon(true)
            local enemy = entity.get_threat();
            local lp_origin = entity.get_origin(me.player);
            local enemy_origin = entity.get_origin(enemy) or 0
            local diff = lp_origin.z - enemy_origin.z
            local state2 = antiaim.get_state()
            if ((string.find(weapon, "knife") or string.find(weapon, "bayo")) or diff > 64) and string.find(state2, 'duck') then
                refs.rage.anti_aim.angles.at_fov_target:set(true)
                refs.rage.anti_aim.desync.fake:set(true)
                refs.rage.anti_aim.desync.fake_amount:set(-100)
                refs.rage.anti_aim.desync.compensate_angle:set(0)
                refs.rage.anti_aim.angles.yaw_add:set(true)
                refs.rage.anti_aim.angles.add:set(20)
            end
        end
        if menu.antiaim.additions:get(1) then
            if refs.rage.anti_aim.angles.left:get() or refs.rage.anti_aim.angles.right:get() or refs.rage.anti_aim.angles.freestand:get() then
                refs.rage.anti_aim.angles.at_fov_target:set(true)
                refs.rage.anti_aim.desync.fake:set(true)
                refs.rage.anti_aim.desync.fake_amount:set(-100)
                refs.rage.anti_aim.desync.compensate_angle:set(50)
                refs.rage.anti_aim.angles.yaw_add:set(true)
                refs.rage.anti_aim.angles.add:set(0)
            end
        end
        if menu.antiaim.additions:get(4) then
            local should = false
            entities.for_each(function(ent)
                local class = ent:get_class()
                if class == 'CCSGameRulesProxy' then
                    should = ent:get_prop('m_bWarmupPeriod') == true
                end
            end)
            if should then
                refs.rage.anti_aim.angles.pitch:set(3)
                refs.rage.anti_aim.angles.yaw_add:set(false)
                refs.rage.anti_aim.angles.at_fov_target:set(true)
                refs.rage.anti_aim.desync.fake:set(false)
                refs.rage.anti_aim.angles.spin:set(true)
                refs.rage.anti_aim.angles.spin_range:set(360)
                refs.rage.anti_aim.angles.spin_speed:set(180)
            end
        end
        if menu.antiaim.additions:get(4) then
            if rage.get_targets() == 0 then
                refs.rage.anti_aim.angles.pitch:set(3)
                refs.rage.anti_aim.angles.yaw_add:set(false)
                refs.rage.anti_aim.angles.at_fov_target:set(true)
                refs.rage.anti_aim.desync.fake:set(false)
                refs.rage.anti_aim.angles.spin:set(true)
                refs.rage.anti_aim.angles.spin_range:set(360)
                refs.rage.anti_aim.angles.spin_speed:set(180)
            end
        end
    end)

    local notify         = { logs = {} }
    notify.add           = function(self, text, color)
        return table.insert(notify.logs, 1, { text = text, color = color, alpha = 0, time = globals.curtime + 3 })
    end
    local hitgroups      = {
        [0] = 'generic',
        [1] = 'head',
        [2] = 'chest',
        [3] = 'stomach',
        [4] = 'left arm',
        [5] = 'right arm',
        [6] = 'left leg',
        [7] = 'right leg',
        [8] = 'neck',
        [10] = 'gear'
    }
    local hitgroup_names = {
        "generic",
        "head",
        "chest",
        "stomach",
        "left arm",
        "right arm",
        "left leg",
        "right leg",
        "neck",
        "?",
        "gear"
    } --[[
    events.aim_ack:set(function (e)
        local target = engine.get_player_info(e.target).name
        local hitbox = hitgroup_names[e.client_hitgroup + 1]
        local backtrack = e.backtrack
        local hitchance = e.hitchance
        local fixhitchance = math.floor(e.hitchance)
        local safepoint = e.secure
        local damagec = e.server_damage
        local reason = e.result == "unk" and "unknown" or e.result
        local manual = e.manual
        local remaining_hp = e.target ~= -1 and entities.get_entity(e.target):get_prop("m_iHealth") or
            0
        local clr = color('#E6E6EFF')
        if reason == "hit" and not manual then
            notify:add(string.format('hit %s in %s'))
        end
        if reason ~= "hit" and not manual then
            if reason == "spread" then
                clr = color(200, 200, 125)
                reason = "inaccuracy"
            end
            if reason == "resolve" then
                clr = color(200, 45, 45)
                reason = "correction"
            end

            log.add(
                ("Missed %s %s due to %s (bt: %s, hc: %s)"):format(target, hitbox, reason, backtrack,
                    fixhitchance),
                clr, menu.visuals.logs_type:get(1) and menu.visuals.logs:get())
        end
    end)
    --альфа 127
    local test = ui.keybind('test', 'lua>tab b')
    events.render:set(function()
        local anima = global_vars.frametime * 11
        visual.anims.logs = test:get() and math.max(0, math.min(1, visual.anims.logs + anima)) or math.max(0, math.min(1, visual.anims.logs - anima));
        local startpos = -115
        local endpose = 115 * visual.anims.logs
        local add = 0
        render.log(vector(x + startpos + endpose , y + 25), "\aE6E6E67fmissed \aE6E6E6FFl3v1y \aE6E6E67fin \aE6E6E6FFhead \aE6E6E67fdue to \aE6E6E6FFresolver", add)
        add = add + 30
        render.log(vector(x - startpos - endpose , y + 25), "\aE6E6E67fhit \aE6E6E6FFyuki \aE6E6E67fin \aE6E6E6FFleg", add)
    end)
]]
    function on_shutdown()
        db.save("names", config.names)
        db.save("configs", config.configs)
    end

    events.render:set(function()
        local accent = helpers.to_hex(menu.visual.color:get().r, menu.visual.color:get().g, menu.visual.color:get().b,
            menu.visual.color:get().a)
        local base = helpers.to_hex(200, 200, 200, 255)
        if menu.visual.watermark:get() == 0 then
            render.text('cb', vector(size.x / 2, size.y - 25), 'nightproject', color(base), true)
        end
        if menu.visual.watermark:get() == 1 then
            local target = entity.get_threat() ~= nil and tostring(entity.get_threat():get_player_info().name) or 'none'
            local text = string.format('NIGHT [RECODE] | L3V1Y | %s%s',
                engine.is_in_game() and math.round(utils.get_rtt() * 900) or '', not engine.is_in_game() and '' or 'ms')
            render.text('-', vector(15, size.y / 2 - 25), text, color(255))
            local sizex = render.get_text_size('-', text).x
            render.rect_multicolor(vector(15, size.y / 2 - 15), vector(sizex / 2, 1), color(255, 255, 255, 0),
                color(255, 255, 255, 255), color(255, 255, 255, 255), color(255, 255, 255, 0))
            render.rect_multicolor(vector(15 + sizex / 2, size.y / 2 - 15), vector(sizex / 2, 1), color(255, 255, 255,
                255), color(255, 255, 255, 0), color(255, 255, 255, 0), color(255, 255, 255, 255))
            render.text('-', vector(15, size.y / 2 - 10), string.format('-CONIDITON: %s', antiaim.get_state()),
                color(255))
            render.text('-', vector(15, size.y / 2), string.format('-TARGET: %s', target), color(255))
            render.text('-', vector(15, size.y / 2 + 10),
                string.format('-EXPLOIT CHARGE: %s',
                    (info.fatality.can_fastfire or refs.rage.aimbot.aimbot.hide_shot:get()) and 1 or 0), color(255))
            render.text('-', vector(15, size.y / 2 + 20),
                string.format('-DESYNC: %s°', math.round(math.abs(antiaim.get_side(true)))), color(255))
        end
        if menu.visual.watermark:get() == 2 then
            local text = visual.gradient('N I G H T', globals.realtime, color(255), color(55))

            render.text('c', vector(15, size.y / 2 - 15),
                string.format('%s \a%s[%s]', text, accent, night.build:upper()), color(255))
        end
        if menu.visual.watermark:get() == 3 then
            local text = visual.gradient(night.build, globals.realtime, color(accent), color(55))
            render.texture(render.icon, vector(10, size.y / 2 - 15), vector(25, 25))
            render.text('-', vector(40, size.y / 2 - 10), 'night.project', color(200))
            render.text('-', vector(40, size.y / 2), string.format('user: %s [%s\a%s]', 'L3V1Y', text, base), color(200))
        end
    end)

    events.createmove:set(function()
        refs.rage.aimbot.weapon.hitchance:set_path(string.format("rage>aimbot>%s>hitchance", rage.get_weapon()));
        refs.rage.aimbot.weapon.min_damage:set_path(string.format("rage>aimbot>%s>min-damage", rage.get_weapon()));
        refs.rage.aimbot.weapon.override:set_path(string.format("rage>aimbot>%s>override", rage.get_weapon()));
        refs.rage.aimbot.weapon.min_damage_override:set_path(string.format("rage>aimbot>%s>min-damage override",
            rage.get_weapon()));
    end)

    visual.indicator = {
        {
            ref = refs.rage.aimbot.aimbot.double_tap,
            name = 'doubletap',
            anim = 0
        },
        {
            ref = refs.rage.aimbot.aimbot.hide_shot,
            name = 'hideshots',
            anim = 0
        },
        {
            ref = refs.rage.aimbot.weapon.override,
            name = 'damage',
            anim = 0
        },
    }

    events.render:set(function()
        if me.player == nil or not me.valid or not me.player:is_alive() then return end
        local add = 0
        local anim = global_vars.frametime * 10
        visual.anims.indicator = menu.visual.indicator:get() and math.max(0, math.min(1, visual.anims.indicator + anim)) or
            math.max(0, math.min(1, visual.anims.indicator - anim));
        if not (visual.anims.indicator > 0.01) then return end
        visual.anims.scope = me.player:get_prop('m_bIsScoped') and math.max(0, math.min(1, visual.anims.scope + anim)) or
            math.max(0, math.min(1, visual.anims.scope - anim)) * visual.anims.indicator
        local accent = helpers.to_hex(menu.visual.color:get().r, menu.visual.color:get().g, menu.visual.color:get().b,
            255 * visual.anims.indicator)
        local font = menu.visual.font_indicator:get() == 0 and 'c' or '-'
        local xadd = 35 * visual.anims.scope
        local text = visual.gradient('night.project', globals.realtime, color(accent),
            color(55, 55, 55, 255 * visual.anims.indicator))
        render.text(font, vector(x + xadd, y + 20), text, color(200, 200, 200, 255), true)
        for k, v in pairs(visual.indicator) do
            v.anim = v.ref:get() and math.max(0, math.min(1, v.anim + anim)) or math.max(0, math.min(1, v.anim - anim));
            v.sub = string.sub(v.name, 1, (#v.name * v.anim * visual.anims.indicator))
            v.scope = (render.get_text_size(font, menu.visual.animated:get() and v.sub or v.name).x / 2 + 6) *
                visual.anims.scope
            render.text(font, vector(x + v.scope, y + (font == 'c' and 31 or 30) + add),
                menu.visual.animated:get() and v.sub or v.name,
                color(menu.visual.color:get().r, menu.visual.color:get().g, menu.visual.color:get().b,
                    255 * v.anim * visual.anims.indicator), true)
            add = add + 10 * v.anim * visual.anims.indicator
        end
    end)
    events.render:set(function()
        local offset, length, speed = menu.visual.scope.offset:get() * size.y / 1080,
            menu.visual.scope.length:get() * size.y / 1080, menu.visual.scope.speed:get()
        local FT = speed > 0 and globals.frametime * speed or 1
        visual.anims.custom_scope = easing.linear(visual.anims.custom_scope, 0, 1, 1)
        visual.anims.custom_scope = math.clamp(
            visual.anims.custom_scope +
            (me.valid and me.player ~= nil and (menu.visual.scope_enable:get() and me.player:get_prop('m_bIsScoped')) and FT or -FT),
            0, 1)
        local r, g, b, a = menu.visual.scope_color:get().r, menu.visual.scope_color:get().g,
            menu.visual.scope_color:get().b, menu.visual.scope_color:get().a
        if not (visual.anims.custom_scope > 0.01) then return end

        if not menu.visual.scope.removals:get(4) then
            render.rect_multicolor(vector(size.x / 2 - length, size.y / 2), vector(length - offset, 1),
                color(r, g, b, 0), color(r, g, b, a * visual.anims.custom_scope),
                color(r, g, b, a * visual.anims.custom_scope), color(r, g, b, 0))
        end
        if not menu.visual.scope.removals:get(1) then
            render.rect_multicolor(vector(size.x / 2, size.y / 2 - length), vector(1, length - offset),
                color(r, g, b, 0), color(r, g, b, 0),
                color(r, g, b, a * visual.anims.custom_scope), color(r, g, b, a * visual.anims.custom_scope))
        end
        if not menu.visual.scope.removals:get(3) then
            render.rect_multicolor(vector(size.x / 2, size.y / 2 + offset + 1), vector(1, length - offset),
                color(r, g, b, a * visual.anims.custom_scope), color(r, g, b, a * visual.anims.custom_scope),
                color(r, g, b, 0), color(r, g, b, 0))
        end
        if not menu.visual.scope.removals:get(2) then
            render.rect_multicolor(vector(size.x / 2 + offset + 1, size.y / 2), vector(length - offset, 1),
                color(r, g, b, a * visual.anims.custom_scope), color(r, g, b, 0),
                color(r, g, b, 0), color(r, g, b, a * visual.anims.custom_scope))
        end
    end)
    rage.tick = 0
    events.aim_ack:set(function()
        if menu.misc.fakelag:get() then
            rage.tick = globals.tickcount + 4
        end
    end)

    events.createmove:set(function()
        local should_override = ((refs.rage.aimbot.aimbot.double_tap:get() or refs.rage.aimbot.aimbot.hide_shot:get()) or rage.tick > globals.tickcount)
        refs.rage.anti_aim.fakelag.limit:override(
            should_override and menu.misc.fakelag:get() or not should_override and menu.misc.fakelag:get(),
            not should_override and menu.misc.fakelag:get() and utils.random_int(1, 14) or 1)
    end)
    local ground_tick = 1
    local end_time = 0
    events.pre_render:set(function()
        if not me.valid or not me.player then return end
        if me.player == nil or not me.player:is_alive() then return end
        local local_player = GetClientEntityFN(VClientEntityList, engine.get_local_player())
        local NULL = 0x0
        if not local_player or local_player == NULL or local_player == nil then return end
        local on_land = bit.band(me.player:get_prop("m_fFlags"), bit.lshift(1, 0)) ~= 0
        local curtime = globals.curtime

        if on_land == true then
            ground_tick = ground_tick + 1
        else
            ground_tick = 0
            end_time = curtime + 1
        end

        if menu.misc.ground:get() == 1 then
            refs.rage.anti_aim.desync.leg_slide:set(2)
            breakers.set_pose(local_player, 0, -180, 179)
        end
        if menu.misc.ground:get() == 2 then
            refs.rage.anti_aim.desync.leg_slide:set(2)
            if globals.tickcount % 4 > 1 then
                breakers.set_pose(local_player, 0, -180, 179)
            end
        end
        if menu.misc.ground:get() == 3 then
            refs.rage.anti_aim.desync.leg_slide:set(1)
            breakers.set_pose(local_player, 7, .5, 0.9)
        end
        if menu.misc.ground:get() == 4 then
            refs.rage.anti_aim.desync.leg_slide:set(1)
            breakers.set_pose(local_player, 9, utils.random_int(0, 10) / 10, utils.random_int(0, 9) / 10)
            breakers.set_pose(local_player, 10, utils.random_int(0, 10) / 10, utils.random_int(0, 9) / 10)
        end
        if menu.misc.air:get() == 1 then
            breakers.set_pose(local_player, 6, 0.9, .9)
        end
        if menu.misc.air:get() == 2 then
            if globals.tickcount % 4 > 1 then
                breakers.set_pose(local_player, 6, 0.9, .9)
            end
        end
        if menu.misc.air:get() == 3 then
            breakers.set_pose(local_player, 6, utils.random_int(0, 10) / 10, utils.random_int(0, 9) / 10)
        end
        if menu.misc.pitch:get() then
            if ground_tick > 1 and end_time > curtime and not antiaim.in_air then
                breakers.set_pose(local_player, 12, 0, .9)
            end
        end
    end)
    events.setup_move:set(function()
        local self_index = engine.get_local_player()
        local local_player = GetClientEntityFN(VClientEntityList, self_index)
        local NULL = 0x0

        if not local_player or local_player == NULL then
            return
        end

        local pose_parameters_cache = animation_breakers.collected_cache

        for key, cache in pairs(pose_parameters_cache) do
            breakers.set_pose(local_player, key)
        end
    end)

    QAngle.x = 0
    QAngle.y = 0
    QAngle.z = 0

    function on_bullet_impact(event)
        if not menu.visual.spark:get() then return end
        local a = 8
        local b = 5
        if not vec3.x or not vec3.y or not vec3.z then return end
        local lp = me.player
        if not lp then return end
        local userid = lp:get_player_info().user_id
        if menu.visual.spark:get() then
            if userid ~= event:get_int("userid") then return end
        end
        vec3.x = event:get_float("x")
        vec3.y = event:get_float("y")
        vec3.z = event:get_float("z")
        FX_ElectricSpark(vec3, a, b, QAngle)
    end

    events.render:set(function()
        refs.rage.aimbot.weapon.hitchance:override(menu.misc.hitchance:get(), menu.misc.hitchance_int:get())
    end)
    local hit = {shot = 0, hit = 0}
    events.aim_ack:set(function (e)
        hit.shot = hit.shot + 1
        if e.result == 'hit' then
            hit.hit = hit.hit + 1
        end
    end)
    function on_round_start()
        hit = {shot = 0, hit = 0}
    end
    events.render:set(function()
        if not me.valid or not me.player:is_alive() then return end
        if not menu.visual.gamesense:get() then return end
        local dst = 0
        if menu.visual.gamesense_list:get(1) and refs.rage.aimbot.aimbot.double_tap:get() then
            render.push_indicator("DT", info.fatality.can_fastfire and color(200, 200, 200, 255) or
                color(255, 0, 50, 255), dst)
            dst = dst + 41
        end
        if menu.visual.gamesense_list:get(2) and refs.rage.aimbot.aimbot.hide_shot:get() and not refs.rage.aimbot.aimbot.double_tap:get() then
            render.push_indicator("OSAA", color(200, 200, 200, 255), dst)
            dst = dst + 41
        end
        if menu.visual.gamesense_list:get(3) and refs.rage.aimbot.aimbot.target_dormant:get() then
            local bool = entity.get_threat() ~= nil and entity.get_threat():is_valid() == false or false
            render.push_indicator("DA",
                bool and
                color(200, 200, 200, 255) or
                color(255, 0, 50, 255), dst)
            dst = dst + 41
        end
        local clr = (antiaim.get_velocity(me.player):length() > 250 or antiaim.get_velocity(me.player).z > 250 and not info.fatality.can_fastfire) and
            color(143, 194, 21, 255) or color(255, 0, 50, 255)
        if menu.visual.gamesense_list:get(4) then
            render.push_indicator("LC", clr, dst)
            dst = dst + 41
        end
        if menu.visual.gamesense_list:get(5) and refs.misc.movement.fake_duck:get() then
            render.push_indicator("DUCK", color(200, 200, 200, 255), dst)
            dst = dst + 41
        end
        if menu.visual.gamesense_list:get(6) and refs.rage.aimbot.aimbot.force_extra_safety:get() then
            render.push_indicator("SAFE", color(200, 200, 200, 255), dst)
            dst = dst + 41
        end
        if menu.visual.gamesense_list:get(7) and refs.rage.aimbot.weapon.override:get() then
            render.push_indicator("MD", color(200, 200, 200, 255), dst)
            dst = dst + 41
        end
        if menu.visual.gamesense_list:get(8) and refs.misc.movement.peek:get() then
            render.push_indicator("FS", color(200, 200, 200, 255), dst)
            dst = dst + 41
        end
        if menu.visual.gamesense_list:get(9) and menu.misc.hitchance:get() then
            render.push_indicator("HC", color(200, 200, 200, 255), dst)
            dst = dst + 41
        end
        if menu.visual.gamesense_list:get(10) then
            night.debug(tostring(hit.hit / hit.shot) ~= 'inf')
            render.push_indicator(string.format('%s/%s (%s%s)', hit.hit, hit.shot, hit.hit ~= 0 and math.round((hit.hit / hit.shot) * 100) or 0, "%"), color(200, 200, 200, 255), dst)
            dst = dst + 41
        end
    end)
end
funcs.init()
